// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `ClientInner`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>
abstract class Client implements RustOpaqueInterface {
  /// Get the underlying blob client for advanced operations
  Future<void> blobClient();

  /// Create a new ClientBuilder for constructing a Client
  static Future<ClientBuilder> builder() =>
      RustLib.instance.api.zoeClientClientClientBuilder();

  /// Check if a file exists in storage
  ///
  /// # Arguments
  ///
  /// * `stored_info` - Metadata from when the file was stored
  ///
  /// # Returns
  ///
  /// `true` if the file exists in storage, `false` otherwise
  Future<bool> hasFile({required FileRef storedInfo});

  /// Retrieve a file from storage and decrypt it
  ///
  /// This method:
  /// 1. Retrieves the encrypted data from blob storage using the hash
  /// 2. Decrypts the data using the provided encryption info
  /// 3. Returns the original file content
  ///
  /// # Arguments
  ///
  /// * `stored_info` - Metadata from when the file was stored
  ///
  /// # Returns
  ///
  /// The original file content as bytes
  Future<Uint8List> retrieveFile({required FileRef storedInfo});

  /// Save retrieved file content to disk
  ///
  /// This is a convenience method that combines `retrieve_file` with writing to disk.
  ///
  /// # Arguments
  ///
  /// * `stored_info` - Metadata from when the file was stored
  /// * `output_path` - Path where to write the retrieved file
  Future<void> retrieveFileToDisk({
    required FileRef storedInfo,
    required Path outputPath,
  });

  /// Store raw data (not from a file) with encryption and blob storage
  ///
  /// This method allows storing arbitrary data without reading from disk.
  ///
  /// # Arguments
  ///
  /// * `data` - The raw data to store
  /// * `reference_name` - A reference name for the data (used in metadata)
  /// * `content_type` - Optional content type for metadata
  ///
  /// # Returns
  ///
  /// `FileRef` containing the blob hash, encryption info, and metadata
  Future<FileRef> storeData({
    required List<int> data,
    required String referenceName,
    String? contentType,
  });

  /// Store a file by reading from disk, encrypting, and storing in blob storage
  ///
  /// This method:
  /// 1. Reads the file from the provided path
  /// 2. Encrypts the content using convergent encryption
  /// 3. Stores the encrypted data in the blob store
  /// 4. Returns metadata needed to retrieve the file later
  ///
  /// # Arguments
  ///
  /// * `file_path` - Path to the file to store
  ///
  /// # Returns
  ///
  /// `FileRef` containing the blob hash, encryption info, and metadata
  Future<FileRef> storeFile({required Path filePath});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientBuilder>>
abstract class ClientBuilder implements RustOpaqueInterface {
  Future<Client> build();

  Future<void> clientSecret({required ClientSecret secret});

  static Future<ClientBuilder> default_() =>
      RustLib.instance.api.zoeClientClientClientBuilderDefault();

  Future<void> mediaStoragePath({required String mediaStoragePath});

  Future<void> serverInfo({
    required VerifyingKey serverPublicKey,
    required SocketAddr serverAddr,
  });

  Future<void> signingKey({required SigningKey signingKey});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientSecret>>
abstract class ClientSecret implements RustOpaqueInterface {
  Future<String> asHex();

  static Future<ClientSecret> fromHex({required String value}) =>
      RustLib.instance.api.zoeClientClientClientSecretFromHex(value: value);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FileRef>>
abstract class FileRef implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Path>>
abstract class Path implements RustOpaqueInterface {}
