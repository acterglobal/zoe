// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import '../../../lib.dart';
import '../../zoe_wire_protocol/keys.dart';
import '../../zoe_wire_protocol/primitives.dart';
import '../file/image.dart';
import '../identity.dart';
import '../metadata.dart';
import 'events/permissions.dart';
import 'events/roles.dart';
import 'events/settings.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `GroupStateError`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `apply_event`, `check_permission`, `description`, `from_group_info`, `generic_metadata`, `get_members`, `is_member`, `member_role`, `new`, `to_group_info`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<GroupMembership>>
abstract class GroupMembership implements RustOpaqueInterface {
  /// Get all identities that a verifying key can act as
  Future<Set<IdentityRef>> availableIdentities({required VerifyingKey key});

  static Future<GroupMembership> default_() =>
      RustLib.instance.api.zoeAppPrimitivesGroupStatesGroupMembershipDefault();

  /// Get display name for an identity
  Future<String> displayName({
    required VerifyingKey key,
    required IdentityType identityType,
  });

  /// Get effective role when a key acts as a specific identity
  Future<GroupRole?> effectiveRole({
    required VerifyingKey key,
    String? actingAsAlias,
  });

  /// Check if a verifying key is authorized to act as a specific identity
  Future<bool> isAuthorized({
    required VerifyingKey key,
    required IdentityRef identityRef,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  /// Create a new empty membership state
  static Future<GroupMembership> newInstance() =>
      RustLib.instance.api.zoeAppPrimitivesGroupStatesGroupMembershipNew();

  /// Get the role for a specific identity
  Future<GroupRole?> role({required IdentityRef identityRef});
}

/// The complete runtime state of a distributed encrypted group.
///
/// `GroupState` represents the unified, authoritative state of a group at any point in time.
/// It combines immutable group information (from [`super::events::GroupInfo`]) with runtime
/// state such as active members, event history, and identity management.
///
/// ## üèóÔ∏è Design Philosophy
///
/// This type unifies what were previously separate concerns:
/// - **Static Group Information**: Name, settings, and structured metadata
/// - **Dynamic Member State**: Active participants, roles, and activity tracking
/// - **Event History**: Audit trail and conflict resolution capability
/// - **Identity Management**: Complex alias and display name handling
///
/// ## üîÑ Event-Sourced Architecture
///
/// Groups maintain state through event sourcing:
/// ```text
/// CreateGroup Event ‚Üí Initial GroupState
///        ‚Üì
/// Member Activity ‚Üí Updated GroupState (new member added)
///        ‚Üì
/// Role Assignment ‚Üí Updated GroupState (permissions changed)
///        ‚Üì
/// Group Update ‚Üí Updated GroupState (metadata modified)
/// ```
///
/// Each event is applied via [`GroupState::apply_event`], ensuring consistency
/// and providing an audit trail through [`GroupState::event_history`].
///
/// ## üîê Security and Access Control
///
/// ### Encryption-Based Membership
/// - Anyone with the group's encryption key can participate
/// - [`GroupState::members`] tracks known active participants, not access control
/// - True access control is enforced by possession of the encryption key
///
/// ### Role-Based Permissions
/// - Each member has a [`super::events::roles::GroupRole`] defining their capabilities
/// - Permissions are checked via [`GroupState::check_permission`]
/// - Role assignments are cryptographically signed and part of the event history
///
/// ### Identity Privacy
/// - Members can use aliases within groups via [`GroupMembership`]
/// - Display names can be set independently of cryptographic identities
/// - Multiple aliases per [`zoe_wire_protocol::VerifyingKey`] are supported
///
/// ## üìä Member Lifecycle
///
/// 1. **Discovery**: A user obtains the group encryption key through some secure channel
/// 2. **Announcement**: User sends any [`super::events::GroupActivityEvent`] to announce participation
/// 3. **Recognition**: Internal handling adds them to active member list
/// 4. **Activity**: Member's [`GroupMember::last_active`] is updated with each message
/// 5. **Departure**: [`super::events::GroupActivityEvent::LeaveGroup`] removes from active list
///
/// Note: Departure only removes from the active member tracking - the user still
/// possesses the encryption key and could rejoin at any time.
///
/// ## üè∑Ô∏è Structured Metadata System
///
/// Metadata is stored as [`crate::Metadata`] variants rather than simple key-value pairs:
/// - [`crate::Metadata::Description`]: Human-readable group description
/// - [`crate::Metadata::Generic`]: Key-value pairs for backward compatibility
/// - Future variants can add typed metadata (images, files, etc.)
///
/// Use [`GroupState::description()`] and [`GroupState::generic_metadata()`] for
/// convenient access to common metadata patterns.
///
/// ## üîó Relationship to GroupInfo
///
/// [`super::events::GroupInfo`] is used for events (creation, updates) while
/// `GroupState` represents the current runtime state:
///
/// ```text
/// GroupInfo (in events) ‚Üí GroupState (runtime) ‚Üí GroupInfo (for updates)
/// ```
///
/// Use [`GroupState::from_group_info`] and [`GroupState::to_group_info`] to
/// convert between representations.
///
/// ## üí° Usage Examples
///
/// ### Creating a Group State
/// ```rust
/// use zoe_app_primitives::{GroupState, GroupSettings, Metadata};
/// use zoe_wire_protocol::KeyPair;
/// use blake3::Hash;
///
/// let creator_key = KeyPair::generate(&mut rand::rngs::OsRng);
/// let group_id = Hash::from([1u8; 32]);
///
/// let metadata = vec![
///     Metadata::Description("Development team coordination".to_string()),
///     Metadata::Generic { key: "department".to_string(), value: "engineering".to_string() },
/// ];
///
/// let group_state = GroupState::new(
///     group_id,
///     "Dev Team".to_string(),
///     GroupSettings::default(),
///     metadata,
///     creator_key.public_key(),
///     1234567890,
/// );
///
/// // Creator is automatically added as Owner
/// assert_eq!(group_state.members.len(), 1);
/// assert!(group_state.is_member(&creator_key.public_key()));
/// ```
///
/// ### Processing Member Activity
/// ```rust
/// # use zoe_app_primitives::*;
/// # use zoe_wire_protocol::KeyPair;
/// # use blake3::Hash;
/// # let mut group_state = GroupState::new(
/// #     Hash::from([1u8; 32]), "Test".to_string(), GroupSettings::default(),
/// #     vec![], KeyPair::generate(&mut rand::rngs::OsRng).public_key(), 1234567890
/// # );
///
/// let new_member = KeyPair::generate(&mut rand::rngs::OsRng);
/// let activity_event = GroupActivityEvent::Activity(());
///
/// // New member announces participation
/// group_state.apply_event(
///     &activity_event,
///     Hash::from([2u8; 32]),
///     new_member.public_key(),
///     1234567891,
/// ).unwrap();
///
/// // They're now tracked as an active member
/// assert!(group_state.is_member(&new_member.public_key()));
/// ```
///
/// ### Working with Metadata
/// ```rust
/// # use zoe_app_primitives::*;
/// # use zoe_wire_protocol::KeyPair;
/// # use blake3::Hash;
/// # let group_state = GroupState::new(
/// #     Hash::from([1u8; 32]), "Test".to_string(), GroupSettings::default(),
/// #     vec![Metadata::Description("Test group".to_string())],
/// #     KeyPair::generate(&mut rand::rngs::OsRng).public_key(), 1234567890
/// # );
///
/// // Extract specific metadata types
/// assert_eq!(group_state.description(), Some("Test group".to_string()));
///
/// // Get all generic metadata as a map
/// let generic_meta = group_state.generic_metadata();
/// ```
class GroupState {
  /// The group identifier - this is the Blake3 hash of the CreateGroup message
  /// Also serves as the root event ID (used as channel tag)
  final MessageId groupId;

  /// Current group name
  final String name;

  /// Current group settings
  final GroupSettings settings;

  /// Group metadata as structured types
  final List<Metadata> metadata;

  /// Runtime member state with roles and activity tracking
  /// Keys are ML-DSA verifying keys encoded as bytes for serialization compatibility
  final BTreeMapIdentityRefGroupMember members;

  /// Advanced identity management for aliases and display names
  final GroupMembership membership;

  /// Event history for this group (event ID -> event details)
  final List<MessageId> eventHistory;

  /// Last processed event timestamp (for ordering)
  final BigInt lastEventTimestamp;

  /// State version (incremented on each event)
  final BigInt version;

  const GroupState({
    required this.groupId,
    required this.name,
    required this.settings,
    required this.metadata,
    required this.members,
    required this.membership,
    required this.eventHistory,
    required this.lastEventTimestamp,
    required this.version,
  });

  @override
  int get hashCode =>
      groupId.hashCode ^
      name.hashCode ^
      settings.hashCode ^
      metadata.hashCode ^
      members.hashCode ^
      membership.hashCode ^
      eventHistory.hashCode ^
      lastEventTimestamp.hashCode ^
      version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupState &&
          runtimeType == other.runtimeType &&
          groupId == other.groupId &&
          name == other.name &&
          settings == other.settings &&
          metadata == other.metadata &&
          members == other.members &&
          membership == other.membership &&
          eventHistory == other.eventHistory &&
          lastEventTimestamp == other.lastEventTimestamp &&
          version == other.version;
}
