// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `generate_ed25519`, `generate_for_algorithm`, `generate_ml_dsa44`, `generate_ml_dsa65`, `generate_ml_dsa87`, `generate`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `assert_receiver_is_total_eq`, `clone`, `clone`, `clone`, `clone`, `cmp`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `hash`, `partial_cmp`, `partial_cmp`, `source`, `try_from`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<KeyPair>>
abstract class KeyPair implements RustOpaqueInterface {
  /// Get the algorithm for this key type
  Future<Algorithm> algorithm();

  /// Decode a KeyPair from a PEM string.
  ///
  /// This method can parse PEM files created by `to_pem()`, using `parse_many` to
  /// read multiple PEM blocks and automatically detecting the key type from the
  /// PEM labels to reconstruct the appropriate KeyPair.
  ///
  /// # Arguments
  ///
  /// * `pem_string` - The PEM-formatted string containing key data
  ///
  /// # Returns
  ///
  /// A `KeyPair` instance reconstructed from the PEM data.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use zoe_wire_protocol::KeyPair;
  /// use rand::rngs::OsRng;
  ///
  /// let original = KeyPair::generate_ed25519(&mut OsRng);
  /// let pem_string = original.to_pem().unwrap();
  /// let restored = KeyPair::from_pem(&pem_string).unwrap();
  ///
  /// assert_eq!(original.public_key(), restored.public_key());
  /// ```
  static Future<KeyPair> fromPem({required String pemString}) => RustLib
      .instance
      .api
      .zoeWireProtocolKeysKeyPairFromPem(pemString: pemString);

  Future<void> id();

  Future<VerifyingKey> publicKey();

  Future<Signature> sign({required List<int> message});

  /// Encode the KeyPair to a PEM string suitable for environment variables or file storage.
  ///
  /// This method creates PEM blocks containing:
  /// - For Ed25519: Only the private key (public key can be derived)
  /// - For ML-DSA: Both private and public keys in separate PEM blocks (hash is derived from public key)
  ///
  /// All PEM blocks are prefixed with "ZOE" to identify them as Zoe-specific formats.
  ///
  /// # Returns
  ///
  /// A PEM-formatted string containing the key data.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use zoe_wire_protocol::KeyPair;
  /// use rand::rngs::OsRng;
  ///
  /// let keypair = KeyPair::generate_ed25519(&mut OsRng);
  /// let pem_string = keypair.to_pem().unwrap();
  ///
  /// // Store in environment variable or file
  /// std::env::set_var("MY_PRIVATE_KEY", &pem_string);
  /// ```
  Future<String> toPem();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<KeyPairError>>
abstract class KeyPairError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Signature>>
abstract class Signature implements RustOpaqueInterface {
  /// Encode the Signature to bytes for serialization
  Future<Uint8List> encode();

  Future<void> id();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SigningKey>>
abstract class SigningKey implements RustOpaqueInterface {
  /// Sign a message with this signing key
  Future<Signature> sign({required List<int> message});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyError>>
abstract class VerifyError implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<VerifyingKey>>
abstract class VerifyingKey implements RustOpaqueInterface {
  /// Get the algorithm for this key type
  ///
  /// flutter_rust_bridge:opaque
  Future<Algorithm> algorithm();

  /// Encode the VerifyingKey to bytes for serialization.
  ///
  /// This method serializes the key using postcard format for efficient storage
  /// and transmission. The resulting bytes can be deserialized back to a
  /// `VerifyingKey` using `postcard::from_bytes()`.
  ///
  /// # Returns
  ///
  /// A `Vec<u8>` containing the serialized key data.
  ///
  /// # Examples
  ///
  /// ```rust
  /// use zoe_wire_protocol::{KeyPair, VerifyingKey};
  /// use rand::rngs::OsRng;
  ///
  /// let keypair = KeyPair::generate_ed25519(&mut OsRng);
  /// let verifying_key = keypair.public_key();
  ///
  /// // Serialize the key
  /// let key_bytes = verifying_key.encode();
  ///
  /// // Deserialize it back
  /// let restored_key: VerifyingKey = postcard::from_bytes(&key_bytes).unwrap();
  /// assert_eq!(&verifying_key, &restored_key);
  /// ```
  /// flutter_rust_bridge:opaque
  Future<Uint8List> encode();

  /// flutter_rust_bridge:opaque
  static Future<VerifyingKey> fromHex({required String hex}) =>
      RustLib.instance.api.zoeWireProtocolKeysVerifyingKeyFromHex(hex: hex);

  /// flutter_rust_bridge:opaque
  Future<void> id();

  /// flutter_rust_bridge:opaque
  Future<Uint8List> toBytes();

  /// Verify a signature against a message using the appropriate algorithm.
  ///
  /// This method automatically matches the signature type with the key type
  /// and returns `Ok(false)` if they don't match (rather than an error).
  ///
  /// # Arguments
  ///
  /// * `message` - The message bytes that were signed
  /// * `signature` - The signature to verify
  ///
  /// # Returns
  ///
  /// * `Ok(true)` - Signature is valid for this key and message
  /// * `Ok(false)` - Signature is invalid or key/signature types don't match
  /// * `Err(_)` - Verification error (malformed signature, etc.)
  ///
  /// # Examples
  ///
  /// ```rust
  /// use zoe_wire_protocol::{KeyPair, VerifyingKey, SigningKey};
  /// use rand::rngs::OsRng;
  ///
  /// # fn example() -> Result<(), Box<dyn std::error::Error>> {
  /// let keypair = KeyPair::generate_ed25519(&mut OsRng);
  /// let message = b"Hello, world!";
  /// let signature = keypair.sign(message);
  /// let verifying_key = keypair.public_key();
  ///
  /// let is_valid = verifying_key.verify(message, &signature)?;
  /// assert!(is_valid);
  /// # Ok(())
  /// # }
  /// ```
  /// flutter_rust_bridge:opaque
  Future<void> verify({
    required List<int> message,
    required Signature signature,
  });
}

/// Cryptographic algorithm identifier
enum Algorithm {
  /// Ed25519 elliptic curve signatures
  ed25519,

  /// ML-DSA-44 post-quantum signatures (TLS certificates, ~128-bit security)
  mlDsa44,

  /// ML-DSA-65 post-quantum signatures (messages, ~192-bit security)
  mlDsa65,

  /// ML-DSA-87 post-quantum signatures (high security, ~256-bit security)
  mlDsa87,
}
