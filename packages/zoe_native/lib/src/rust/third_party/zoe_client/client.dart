// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../zoe_app_primitives/connection.dart';
import '../zoe_app_primitives/file.dart';
import '../zoe_state_machine/group.dart';
import '../zoe_wire_protocol/keys.dart';
import '../zoe_wire_protocol/primitives.dart';
import 'client/api.dart';
import 'client/api/file_storage.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>
abstract class Client implements RustOpaqueInterface {
  /// Add a relay server to the client
  ///
  /// This will attempt to connect to all addresses in the RelayAddress in random order
  /// with a 10-second timeout per attempt. Only adds the relay to local state if a
  /// connection succeeds.
  Future<void> addRelay({required RelayAddress address});

  /// Create a new ClientBuilder for constructing a Client
  static Future<ClientBuilder> builder() =>
      RustLib.instance.api.zoeClientClientClientBuilder();

  /// Get the current client secret
  Future<ClientSecret> clientSecret();

  Future<String> clientSecretHex();

  Future<void> close();

  /// Get list of all configured relays with their connection status
  Future<List<RelayConnectionInfo>> getRelayStatus();

  Future<GroupManager> groupManager();

  /// Check if any relays are currently connected
  Future<bool> hasConnectedRelays();

  /// Check if a file exists in storage
  ///
  /// # Arguments
  ///
  /// * `stored_info` - Metadata from when the file was stored
  ///
  /// # Returns
  ///
  /// `true` if the file exists in storage, `false` otherwise
  Future<bool> hasFile({required FileRef storedInfo});

  Future<String> idHex();

  /// Calculate the current overall connection status
  ///
  /// This is computed from the current relay states, ensuring it's always accurate but makes it
  /// a bit more expensive to compute. For live updates it is recommended to use `overall_status_stream`
  /// instead.
  Future<OverallConnectionStatus> overallStatus();

  /// Attempt to reconnect to all failed relays
  Future<BigInt> reconnectFailedRelays();

  /// Remove a relay connection (offline mode only)
  Future<bool> removeRelay({required VerifyingKey serverPublicKey});

  /// Retrieve a file from storage and save it to disk
  ///
  /// This method:
  /// 1. Retrieves the encrypted data from blob storage using the FileRef
  /// 2. Decrypts the content
  /// 3. Writes the decrypted content to the specified path
  ///
  /// # Arguments
  ///
  /// * `file_ref` - Metadata for the file to retrieve
  /// * `output_path` - Path where the decrypted file should be saved
  ///
  /// # Errors
  ///
  /// Returns an error if:
  /// - The file cannot be found in storage
  /// - Decryption fails
  /// - Writing to disk fails
  Future<void> retrieveFile({
    required FileRef fileRef,
    required PathBuf outputPath,
  });

  /// Retrieve a file from storage as bytes
  ///
  /// This method:
  /// 1. Retrieves the encrypted data from blob storage using the FileRef
  /// 2. Decrypts the content
  /// 3. Returns the decrypted content as bytes
  ///
  /// # Arguments
  ///
  /// * `file_ref` - Metadata for the file to retrieve
  ///
  /// # Returns
  ///
  /// The decrypted file content as `Vec<u8>`
  ///
  /// # Errors
  ///
  /// Returns an error if:
  /// - The file cannot be found in storage
  /// - Decryption fails
  Future<Uint8List> retrieveFileBytes({required FileRef fileRef});

  /// Close the client and clean up all resources
  /// Get access to the session manager for PQXDH operations
  ///
  /// This provides access to the underlying session manager which handles
  /// PQXDH protocol handlers and state management.
  ///
  /// # Returns
  ///
  /// A reference to the `SessionManager`
  Future<ArcZoeClientSessionManager> sessionManager();

  /// Store raw data (not from a file) with encryption and blob storage
  ///
  /// This method allows storing arbitrary data without reading from disk.
  ///
  /// # Arguments
  ///
  /// * `data` - The raw data to store
  /// * `reference_name` - A reference name for the data (used in metadata)
  /// * `content_type` - Optional content type for metadata
  ///
  /// # Returns
  ///
  /// `FileRef` containing the blob hash, encryption info, and metadata
  Future<FileRef> storeData({
    required List<int> data,
    required String referenceName,
    String? contentType,
  });

  /// Store a file by reading from disk, encrypting, and storing in blob storage
  ///
  /// This method:
  /// 1. Reads the file from the provided path
  /// 2. Encrypts the content using convergent encryption
  /// 3. Stores the encrypted data in the blob store
  /// 4. Returns metadata needed to retrieve the file later
  ///
  /// # Arguments
  ///
  /// * `file_path` - Path to the file to store
  ///
  /// # Returns
  ///
  /// A `FileRef` containing the metadata needed to retrieve the file
  ///
  /// # Errors
  ///
  /// Returns an error if:
  /// - The file cannot be read
  /// - Encryption fails
  /// - Blob storage operation fails
  Future<FileRef> storeFile({required PathBuf filePath});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientBuilder>>
abstract class ClientBuilder implements RustOpaqueInterface {
  /// Enable or disable automatic connection to server during build
  ///
  /// When autoconnect is true (default for backward compatibility), the client
  /// will require server information and connect immediately during build().
  /// When autoconnect is false, the client starts in offline mode and can
  /// connect to relays later using add_relay().
  Future<void> autoconnect({required bool autoconnect});

  Future<Client> build();

  Future<void> clientSecret({required ClientSecret secret});

  /// Set the storage database path (convenience method)
  Future<void> dbStorageDir({required String path});

  static Future<ClientBuilder> default_() =>
      RustLib.instance.api.zoeClientClientClientBuilderDefault();

  /// Set the encryption key for storage
  Future<void> encryptionKey({required U8Array32 key});

  Future<void> mediaStorageDir({required String mediaStorageDir});

  Future<void> serverInfo({
    required VerifyingKey serverPublicKey,
    required SocketAddr serverAddr,
  });

  Future<void> servers({required List<RelayAddress> servers});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientSecret>>
abstract class ClientSecret implements RustOpaqueInterface {
  static Future<ClientSecret> fromHex({required String hex}) =>
      RustLib.instance.api.zoeClientClientClientSecretFromHex(hex: hex);

  /// Get the list of configured servers
  Future<void> servers();

  Future<String> toHex();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayConnectionInfo>>
abstract class RelayConnectionInfo implements RustOpaqueInterface {
  RelayInfo get info;

  RelayConnectionStatus get status;

  set info(RelayInfo info);

  set status(RelayConnectionStatus status);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayConnectionStatus>>
abstract class RelayConnectionStatus implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayInfo>>
abstract class RelayInfo implements RustOpaqueInterface {
  RelayAddress get relayAddress;

  KeyId get relayId;

  set relayAddress(RelayAddress relayAddress);

  set relayId(KeyId relayId);
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<RelayStatusUpdate>>
abstract class RelayStatusUpdate implements RustOpaqueInterface {
  RelayAddress get relayAddress;

  KeyId get relayId;

  RelayConnectionStatus get status;

  set relayAddress(RelayAddress relayAddress);

  set relayId(KeyId relayId);

  set status(RelayConnectionStatus status);
}

/// Overall connection status for the client
class OverallConnectionStatus {
  /// True if connected to at least one relay
  final bool isConnected;

  /// Number of connected relays
  final BigInt connectedCount;

  /// Total number of configured relays
  final BigInt totalCount;

  const OverallConnectionStatus({
    required this.isConnected,
    required this.connectedCount,
    required this.totalCount,
  });

  @override
  int get hashCode =>
      isConnected.hashCode ^ connectedCount.hashCode ^ totalCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is OverallConnectionStatus &&
          runtimeType == other.runtimeType &&
          isConnected == other.isConnected &&
          connectedCount == other.connectedCount &&
          totalCount == other.totalCount;
}
