// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../zoe_wire_protocol/keys.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `blob_client`, `db_storage_dir_pathbuf`, `inner_keypair`, `media_storage_dir_pathbuf`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Client>>
abstract class Client implements RustOpaqueInterface {
  /// Create a new ClientBuilder for constructing a Client
  static Future<ClientBuilder> builder() =>
      RustLib.instance.api.zoeClientClientClientBuilder();

  Future<String> clientSecretHex();

  Future<void> close();

  /// Check if a file exists in storage
  ///
  /// # Arguments
  ///
  /// * `stored_info` - Metadata from when the file was stored
  ///
  /// # Returns
  ///
  /// `true` if the file exists in storage, `false` otherwise
  Future<bool> hasFile({required FileRef storedInfo});

  Future<String> idHex();

  /// Retrieve a file from storage and save it to disk
  ///
  /// This method:
  /// 1. Retrieves the encrypted data from blob storage using the FileRef
  /// 2. Decrypts the content
  /// 3. Writes the decrypted content to the specified path
  ///
  /// # Arguments
  ///
  /// * `file_ref` - Metadata for the file to retrieve
  /// * `output_path` - Path where the decrypted file should be saved
  ///
  /// # Errors
  ///
  /// Returns an error if:
  /// - The file cannot be found in storage
  /// - Decryption fails
  /// - Writing to disk fails
  Future<void> retrieveFile({
    required FileRef fileRef,
    required PathBuf outputPath,
  });

  /// Retrieve a file from storage as bytes
  ///
  /// This method:
  /// 1. Retrieves the encrypted data from blob storage using the FileRef
  /// 2. Decrypts the content
  /// 3. Returns the decrypted content as bytes
  ///
  /// # Arguments
  ///
  /// * `file_ref` - Metadata for the file to retrieve
  ///
  /// # Returns
  ///
  /// The decrypted file content as `Vec<u8>`
  ///
  /// # Errors
  ///
  /// Returns an error if:
  /// - The file cannot be found in storage
  /// - Decryption fails
  Future<Uint8List> retrieveFileBytes({required FileRef fileRef});

  /// Store raw data (not from a file) with encryption and blob storage
  ///
  /// This method allows storing arbitrary data without reading from disk.
  ///
  /// # Arguments
  ///
  /// * `data` - The raw data to store
  /// * `reference_name` - A reference name for the data (used in metadata)
  /// * `content_type` - Optional content type for metadata
  ///
  /// # Returns
  ///
  /// `FileRef` containing the blob hash, encryption info, and metadata
  Future<FileRef> storeData({
    required List<int> data,
    required String referenceName,
    String? contentType,
  });

  /// Store a file by reading from disk, encrypting, and storing in blob storage
  ///
  /// This method:
  /// 1. Reads the file from the provided path
  /// 2. Encrypts the content using convergent encryption
  /// 3. Stores the encrypted data in the blob store
  /// 4. Returns metadata needed to retrieve the file later
  ///
  /// # Arguments
  ///
  /// * `file_path` - Path to the file to store
  ///
  /// # Returns
  ///
  /// A `FileRef` containing the metadata needed to retrieve the file
  ///
  /// # Errors
  ///
  /// Returns an error if:
  /// - The file cannot be read
  /// - Encryption fails
  /// - Blob storage operation fails
  Future<FileRef> storeFile({required PathBuf filePath});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientBuilder>>
abstract class ClientBuilder implements RustOpaqueInterface {
  Future<Client> build();

  Future<void> clientSecret({required ClientSecret secret});

  /// Set the storage database path (convenience method)
  Future<void> dbStorageDir({required String path});

  static Future<ClientBuilder> default_() =>
      RustLib.instance.api.zoeClientClientClientBuilderDefault();

  /// Set the encryption key for storage
  Future<void> encryptionKey({required U8Array32 key});

  Future<void> mediaStorageDir({required String mediaStorageDir});

  Future<void> serverInfo({
    required VerifyingKey serverPublicKey,
    required SocketAddr serverAddr,
  });
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ClientSecret>>
abstract class ClientSecret implements RustOpaqueInterface {
  static Future<ClientSecret> fromHex({required String hex}) =>
      RustLib.instance.api.zoeClientClientClientSecretFromHex(hex: hex);

  Future<String> toHex();
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<FileRef>>
abstract class FileRef implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<PathBuf>>
abstract class PathBuf implements RustOpaqueInterface {}
