// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../lib.dart';
import '../zoe_app_primitives/file/image.dart';
import '../zoe_app_primitives/group/events/permissions.dart';
import '../zoe_app_primitives/group/events/settings.dart';
import '../zoe_app_primitives/group/states.dart';
import '../zoe_app_primitives/metadata.dart';
import '../zoe_wire_protocol/crypto.dart';
import '../zoe_wire_protocol/primitives.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they have generic arguments: `encrypt_group_event_content`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `GroupSessionError`, `GroupStateSnapshot`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `all_keys`, `decrypt_group_event`, `encrypt_group_event_content`, `new`, `rotate_key`

/// Complete group session state including both group state and encryption keys
/// Since both are stored in the same encrypted database and always used together,
/// combining them reduces complexity and eliminates synchronization issues.
class GroupSession {
  /// The group's business logic state (members, roles, metadata, etc.)
  final GroupState state;

  /// Current encryption key for this group
  final EncryptionKey currentKey;

  /// Previous keys (for decrypting old messages during key rotation)
  final List<EncryptionKey> previousKeys;

  const GroupSession({
    required this.state,
    required this.currentKey,
    required this.previousKeys,
  });

  @override
  int get hashCode =>
      state.hashCode ^ currentKey.hashCode ^ previousKeys.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is GroupSession &&
          runtimeType == other.runtimeType &&
          state == other.state &&
          currentKey == other.currentKey &&
          previousKeys == other.previousKeys;
}
